

Almost every code base I've worked in previously, whether fifteen years old or just a few weeks, fell into the category of legacy code for exactly the reason mentioned in this book. There were no unit-level tests. Without the presence of tests, design had gone to pieces once the architects were no longer looking (if any architects had ever existed!). Without tests' presence, the code had no need to be easily isolated and changed - so it wasn't. This book provides a set of steps to clean up that sort of legacy code in as safe a way as possible, always moving towards a system that is a joy and productive to code in.Additionally, this book codifies good design patterns and ways to think about new code during code reviews. Even "green field" developments can benefit from reading this book and ensuring that early-on work is being done to ensure that it never starts the downward legacy spiral. I would encourage developers starting from scratch to ensure they're following the patterns in this book any time that a bad piece of code sneaks in to keep it from spreading - we have on my team, and it's done wonders for our quality level, productivity, and morale.The only thing I'd like to have seen improved is that there's a an assumption that the code is all in one place - there are no external, uncontrollable sources who build on this code, there are no versioning requirements (i.e. API stability for N years), etc. While I'm sure the majority of this book's audience doesn't have to deal with it, for those who do, noting what constitutes a breaking change and what doesn't (particularly to ensure that each chapter has at least one that isn't) would've really helped for those of us who have to build platforms.



      

Almost every code base I've worked in previously, whether fifteen years old or just a few weeks, fell into the category of legacy code for exactly the reason mentioned in this book. There were no unit-level tests. Without the presence of tests, design had gone to pieces once the architects were no longer looking (if any architects had ever existed!). Without tests' presence, the code had no need to be easily isolated and changed - so it wasn't. This book provides a set of steps to clean up that sort of legacy code in as safe a way as possible, always moving towards a system that is a joy and productive to code in.Additionally, this book codifies good design patterns and ways to think about new code during code reviews. Even "green field" developments can benefit from reading this book and ensuring that early-on work is being done to ensure that it never starts the downward legacy spiral. I would encourage developers starting from scratch to ensure they're following the patterns in this book any time that a bad piece of code sneaks in to keep it from spreading - we have on my team, and it's done wonders for our quality level, productivity, and morale.The only thing I'd like to have seen improved is that there's a an assumption that the code is all in one place - there are no external, uncontrollable sources who build on this code, there are no versioning requirements (i.e. API stability for N years), etc. While I'm sure the majority of this book's audience doesn't have to deal with it, for those who do, noting what constitutes a breaking change and what doesn't (particularly to ensure that each chapter has at least one that isn't) would've really helped for those of us who have to build platforms.
      